The basic API of threading and multiprocessing are similar, but their implementation is very different and multiprocessing has a much larger API to handle the added complexity of multi-process programming. For example, one challenge when converting from threads to processes is how to communicate between processes that are isolated by the operating system and canâ€™t share Python objects. This means that objects crossing process boundaries have to be serialized and deserialized, which creates overhead. In Example 20-3 the only data that crosses the process boundary is the Event state, which is implemented with a low-level OS semaphore in the C code underlying the multiprocessing module.